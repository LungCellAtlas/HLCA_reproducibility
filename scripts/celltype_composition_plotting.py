import scanpy as sc
import pandas as pd
import numpy as np
import ast
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import to_hex


def calculate_hierarchical_coloring_df(
    adata, consensus_df, max_level, lev1_colormap_dict=None, ann_level_name_prefix="original_ann_level_"
):
    """Calculates all the information and color coding needed to plot
    hierarchical atlas cell type information.

    Arguments:
    adata - anndata object, annotated with "ann_level_[level number]" and
        "ann_level_[level_number]_clean" annotations. Unlabeled cells should
        have a [number of finest annotated level]_[name of finest annotated level]
        label in "ann_level_[level number]", and should be labeled "None"
        (string) in "ann_level_[level number]_clean".
    consensus_df - cell type reference overview, as generated by
        reference_based_harmonizing.create_consensus_table() function.
    max_level - number of annotation levels to include.
    lev1_colormap_dict - dictionary mapping level 1 annotations to colormap
        names. If set to None, default colormaps are used.
    ann_level_name_prefix - string of annotation level naming prefix
    Returns:
        pandas dataframe containing proportional and coloring information
        for every level.
    """
    # for every level, get annotations from that level (so no forward-propagated
    # labels) in the order of the consensus-df (which is ordered based on
    # hierarchy, e.g. epithelial cells first, and from those airway epithelial
    # first, etc.)
    # store in a dictionary
    anns = dict()
    for lev in range(1, max_level + 1):
        anns[lev] = list()
        levname = "level_" + str(lev)
        for a, label_lev in zip(consensus_df[levname], consensus_df.highest_res):
            if label_lev >= lev and a not in anns[lev]:
                anns[lev].append(a)
    # set up an empty dataframe, in which we will store all the label- and
    # level-specific information to organize the coloring of the
    column_names = list()
    for lev in range(1, max_level + 1):
        for suff in [
            "label",
            "size",
            "perc",
            #         "parent",
            #         "n_children",
            #         "cmin",
            #         "cmax",
            "cmap",
            "rgba",
        ]:
            column_names.append(f"l{lev}_{suff}")
    color_prop_df = pd.DataFrame(
        index=range(len(set(adata.obs[f"{ann_level_name_prefix}{max_level}"])) + 1),
        columns=column_names,
    )
    # set grey rgba value:
    grey_rgba = str(cm.get_cmap("Greys")(0.5))
    # now fill in bar df. First fill in stuff for level 1, which requires
    # slightly different filling in then the lower levels, since it is the top
    # level.
    # get value counts for level 1 annotations
    lev1_val_c = adata.obs[f"{ann_level_name_prefix}1"].value_counts()
    # sort order based on consensus_df:
    lev1_val_c.loc[[a for a in anns[1] if a in lev1_val_c.index]]
    # fill in labels, number of cells per label
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_label"] = lev1_val_c.index
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_size"] = lev1_val_c.values
    # set cmin and cmax to 0 and 1. Each level_1 group will get its own
    # color map, and the groups will get the mean of cmin and cmax as the color.
    # Since the coloring scale is from 0 to 1, we set those as min and max here.
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmin"] = 0
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmax"] = 1
    # now choose the color maps per level 1 group, (We're assuming that there
    # are 5 groups here.) and store those in the dataframe
    if lev1_colormap_dict == None:
        lev1_colormap_dict = {
            "Epithelial": "Oranges",
            "Immune": "Greens",
            "Endothelial": "Purples",
            "Stroma": "Blues",
            "Proliferating cells": "Reds",
        }
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmap"] = color_prop_df.loc[
        range(0, len(lev1_val_c)), "l1_label"
    ].map(lev1_colormap_dict)
    # now calculate rgba values for every level 1 group, given their colormap,
    # cmin and cmax. Store rgba value as string, so that we can store it
    # in the dataframe.
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_rgba"] = [
        str(cm.get_cmap(parent_cmap)(0.5))
        for parent_cmap in color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmap"]
    ]
    # now start looping through the lower levels:
    for level in range(2, max_level + 1):
        level_labels = list()
        level_label_counts = list()
        level_cmaps = list()
        for parent_label in color_prop_df[f"l{level -1}_label"]:
            # ignore rows without any label (i.e. NA rows)
            if not pd.isnull(parent_label):
                # if the parent label startswith "None", that means the parent
                # is a group of cells that was either not annotated at the previous
                # level ("None_[parent_of_unannotated_group]"), or that was not annotated
                # at this level. These groups should be given a grey color.
                if parent_label.startswith("None"):
                    # copy the number of cells from the previous level
                    none_count_from_previous_level = color_prop_df.loc[
                        color_prop_df[f"l{level-1}_label"] == parent_label,
                        f"l{level-1}_size",
                    ].values
                    # this is just a check to make sure there are no duplicate
                    # labels in the dataframe
                    if len(none_count_from_previous_level) != 1:
                        raise ValueError(
                            "non_count_from_previous_level should have length 1! Something went wrong."
                        )
                    # store label information
                    level_labels.append(parent_label)
                    level_label_counts.append(none_count_from_previous_level[0])
                    level_cmaps.append("None")

                else:
                    # select the cells from the parent
                    subobs = adata.obs.loc[
                        adata.obs[f"{ann_level_name_prefix}{level-1}"] == parent_label,
                        f"{ann_level_name_prefix}{level}_clean",
                    ]
                    # check if there are any cells of this label..
                    if subobs.shape[0] != 0:
                        # calculate the frequency of every subtype of this
                        # parent label
                        ann_val_counts = subobs.value_counts()
                        # store number of unique annotations:
                        ann_val_counts = ann_val_counts.loc[ann_val_counts > 0]
                        # check if there are any un-annotated cells in this
                        # subgroup. If so, remember that
                        if "None" in ann_val_counts.index:
                            has_none = True
                        else:
                            has_none = False
                        # copy color map name from parent
                        parent_cmap = color_prop_df.loc[
                            color_prop_df[f"l{level - 1}_label"] == parent_label,
                            f"l{level - 1}_cmap",
                        ].values[0]
                        # sort cell type labels based on reference (order
                        # as stored in anns dictionary), and store as new variable
                        # note that this will not include any "None" group
                        ordered_sublabels = [
                            a for a in anns[level] if a in ann_val_counts.index
                        ]
                        level_labels += ordered_sublabels
                        # store counts
                        level_label_counts += ann_val_counts[ordered_sublabels].tolist()
                        if has_none:
                            level_labels.append(f"None_{parent_label}")
                            level_label_counts.append(ann_val_counts["None"])
                            level_cmaps += (len(ordered_sublabels) + 1) * [parent_cmap]
                        else:
                            level_cmaps += len(ordered_sublabels) * [parent_cmap]
        # fill in table:
        color_prop_df.loc[:,f"l{level}_label"].iloc[: len(level_labels)] = level_labels
        color_prop_df.loc[:,f"l{level}_size"].iloc[: len(level_labels)] = level_label_counts
        color_prop_df.loc[:,f"l{level}_cmap"].iloc[: len(level_labels)] = level_cmaps
        # add colors:
        rows_with_value = [
            row
            for row, label in enumerate(color_prop_df[f"l{level}_label"])
            if not pd.isnull(label)
        ]
        None_rows = [
            row
            for row in rows_with_value
            if color_prop_df[f"l{level}_label"][row].startswith("None")
        ]
        color_prop_df.loc[:,f"l{level}_rgba"].iloc[None_rows] = grey_rgba
        labeled_rows = [row for row in rows_with_value if row not in None_rows]
        for cmap in lev1_colormap_dict.values():
            labeld_rows_from_cmap = [
                row
                for row in labeled_rows
                if color_prop_df[f"l{level}_cmap"][row] == cmap
            ]
            n_colors = len(labeld_rows_from_cmap)
            cmap_idc = np.linspace(0, 1, n_colors + 1)[1:]
            color_prop_df.loc[:,f"l{level}_rgba"].iloc[labeld_rows_from_cmap] = [
                str(cm.get_cmap(cmap)(cmap_idx)) for cmap_idx in cmap_idc
            ]

    # remove rows with NaN only:
    color_prop_df.dropna(axis=0, how="all", inplace=True)
    # calculate proportions in percentages, and perform some sanity checks:
    for l in range(1, max_level + 1):
        # check if total number of cells is the same for every level:
        if not color_prop_df[f"l1_size"].sum() == color_prop_df[f"l{l}_size"].sum():
            print(
                f"WARNING: Total number of cells in level 1 and level {l} are not the same in the output color_prop_df. Something went wrong!"
            )
        # calculate percentages
        color_prop_df[f"l{l}_perc"] = (
            color_prop_df[f"l{l}_size"] / color_prop_df[f"l{l}_size"].sum() * 100
        )
        # check if percentages add up to 100
        if not np.round(color_prop_df[f"l{l}_perc"].sum()) == 100:
            print(
                f"WARNING: Rounded total percentage for level {l} does not add up to 100! Something went wrong."
            )
    return color_prop_df


def calculate_hierarchical_coloring_df_parent_loyal(
    adata, consensus_df, max_level, lev1_colormap_dict=None
):
    """Calculates all the information and color coding needed to plot
    hierarchical atlas cell type information. This "parent loyal" function
    splits the parents color range for its children, instead of re-scaling
    colors from the same colormap equally between 0 and 1. 
    Advantage: children have similar color shades as their parents.
    Disadvantage: parents with many children have children with indistinguishable
    colors.

    Arguments:
    adata - anndata object, annotated with "ann_level_[level number]" and
        "ann_level_[level_number]_clean" annotations. Unlabeled cells should
        have a [number of finest annotated level]_[name of finest annotated level]
        label in "ann_level_[level number]", and should be labeled "None"
        (string) in "ann_level_[level number]_clean".
    consensus_df - cell type reference overview, as generated by
        reference_based_harmonizing.create_consensus_table() function.
    max_level - number of annotation levels to include.
    lev1_colormap_dict - dictionary mapping level 1 annotations to colormap
        names. If set to None, default colormaps are used.
    Returns:
        pandas dataframe containing proportional and coloring information
        for every level.
    """
    # for every level, get annotations from that level (so no forward-propagated
    # labels) in the order of the consensus-df (which is ordered based on
    # hierarchy, e.g. epithelial cells first, and from those airway epithelial
    # first, etc.)
    # store in a dictionary
    anns = dict()
    for lev in range(1, max_level + 1):
        anns[lev] = list()
        levname = "level_" + str(lev)
        for a, label_lev in zip(consensus_df[levname], consensus_df.highest_res):
            if label_lev >= lev and a not in anns[lev]:
                anns[lev].append(a)
    # set up an empty dataframe, in which we will store all the label- and
    # level-specific information to organize the coloring of the
    column_names = list()
    for lev in range(1, max_level + 1):
        for suff in [
            "label",
            "size",
            "perc",
            "parent",
            "n_children",
            "cmin",
            "cmax",
            "cmap",
            "rgba",
        ]:
            column_names.append(f"l{lev}_{suff}")
    color_prop_df = pd.DataFrame(
        index=range(len(set(adata.obs[f"ann_level_{max_level}"])) + 1),
        columns=column_names,
    )
    # set grey rgba value:
    grey_rgba = str(cm.get_cmap("Greys")(0.5))
    # now fill in bar df. First fill in stuff for level 1, which requires
    # slightly different filling in then the lower levels, since it is the top
    # level.
    # get value counts for level 1 annotations
    lev1_val_c = adata.obs.ann_level_1.value_counts()
    # sort order based on consensus_df:
    lev1_val_c.loc[[a for a in anns[1] if a in lev1_val_c.index]]
    # fill in labels, number of cells per label
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_label"] = lev1_val_c.index
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_size"] = lev1_val_c.values
    # set cmin and cmax to 0 and 1. Each level_1 group will get its own
    # color map, and the groups will get the mean of cmin and cmax as the color.
    # Since the coloring scale is from 0 to 1, we set those as min and max here.
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmin"] = 0
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmax"] = 1
    # now choose the color maps per level 1 group, (We're assuming that there
    # are 5 groups here.) and store those in the dataframe
    if lev1_colormap_dict == None:
        lev1_colormap_dict = {
            "Epithelial": "Oranges",
            "Immune": "Greens",
            "Endothelial": "Purples",
            "Stroma": "Blues",
            "Proliferating cells": "Reds",
        }
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmap"] = color_prop_df.loc[
        range(0, len(lev1_val_c)), "l1_label"
    ].map(lev1_colormap_dict)
    # now calculate rgba values for every level 1 group, given their colormap,
    # cmin and cmax. Store rgba value as string, so that we can store it
    # in the dataframe.
    color_prop_df.loc[range(0, len(lev1_val_c)), "l1_rgba"] = [
        str(cm.get_cmap(parent_cmap)(0.5))
        for parent_cmap in color_prop_df.loc[range(0, len(lev1_val_c)), "l1_cmap"]
    ]
    # now start looping through the lower levels:
    for level in range(2, max_level + 1):
        # count at the how-manieth celltype we are of the current level
        level_ann_count = 0
        # now loop through the parents of the current level, i.e.
        # the labels of one level coarser. We will divide each
        # of the parents into n_children subgroups, and we will
        # bin the color of the parent group into n_children sub-colors.
        for parent_label in color_prop_df[f"l{level -1}_label"]:
            # ignore rows without any label (i.e. NA rows)
            if not pd.isnull(parent_label):
                # if the parent label startswith "None", that means the parent
                # is a group of cells that was either not annotated at the previous
                # level ("None_[parent_of_unannotated_group]"), or that was not annotated
                # at this level. These groups should be given a grey color.
                if parent_label.startswith("None"):
                    # set to same label in next level, so that we know at which
                    # level these cells stopped being annotated
                    color_prop_df.loc[level_ann_count, f"l{level}_label"] = parent_label
                    # set color to grey
                    color_prop_df.loc[level_ann_count, f"l{level}_rgba"] = grey_rgba
                    # copy the number of cells from the previous level
                    none_count_from_previous_level = color_prop_df.loc[
                        color_prop_df[f"l{level-1}_label"] == parent_label, f"l{level-1}_size"
                    ].values
                    # this is just a check to make sure there are no duplicate
                    # labels in the dataframe
                    if len(none_count_from_previous_level) != 1:
                        raise ValueError(
                            "non_count_from_previous_level should have length 1! Something went wrong."
                        )
                        # store the number of cells
                    color_prop_df.loc[
                        level_ann_count, f"l{level}_size"
                    ] = none_count_from_previous_level[0]
                    # add one count to level_ann_count
                    level_ann_count += 1
                # if the current label is an actual label (i.e. does not start with
                # "None")
                else:
                    # select the cells from the parent
                    subobs = adata.obs.loc[
                        adata.obs[f"ann_level_{level-1}"] == parent_label,
                        f"ann_level_{level}_clean",
                    ]
                    # check if there are any cells of this label..
                    if subobs.shape[0] != 0:
                        # calculate the frequency of every subtype of this
                        # parent label
                        ann_val_counts = subobs.value_counts()
                        # store number of unique annotations:
                        ann_val_counts = ann_val_counts.loc[ann_val_counts > 0]
                        # store number of subgroups with at least one cell
                        n_siblings = len(set(ann_val_counts.index))
                        # check if there are any un-annotated cells in this
                        # subgroup. If so, remember that and subtract 1 from
                        # number of siblings.
                        if "None" in ann_val_counts.index:
                            # subtract 1
                            has_none = True
                            n_siblings -= 1
                        else:
                            has_none = False
                        # retrieve cmin and cmax of parent, so that we can
                        # no subdivide this color range into n_siblings parts
                        parent_cmin = color_prop_df.loc[
                            color_prop_df[f"l{level - 1}_label"] == parent_label,
                            f"l{level - 1}_cmin",
                        ]
                        parent_cmax = color_prop_df.loc[
                            color_prop_df[f"l{level - 1}_label"] == parent_label,
                            f"l{level - 1}_cmax",
                        ]
                        # also copy color map name from parent
                        parent_cmap = color_prop_df.loc[
                            color_prop_df[f"l{level - 1}_label"] == parent_label,
                            f"l{level - 1}_cmap",
                        ].values[0]
                        # bin cmins into n_siblings bins, same for cmaxs
                        cmins = np.linspace(parent_cmin, parent_cmax, n_siblings + 1)[
                            :-1
                        ]
                        cmaxs = np.linspace(parent_cmin, parent_cmax, n_siblings + 1)[
                            1:
                        ]
                        # store the bins (matching cmin and cmax) for every sibling
                        color_prop_df.loc[
                            color_prop_df[f"l{level - 1}_label"] == parent_label,
                            f"l{level - 1}_n_children",
                        ] = n_siblings
                        # sort cell type labels based on reference (order
                        # as stored in anns dictionary), and store as new variable
                        # note that this will not include any "None" group
                        ann_val_counts_ordered = ann_val_counts.loc[
                            [a for a in anns[level] if a in ann_val_counts.index]
                        ]
                        # set index to list instead of categorical, so that we
                        # can add new indices:
                        ann_val_counts_ordered.index = (
                            ann_val_counts_ordered.index.tolist()
                        )
                        # if there is a None group in our labels, add this at
                        # the end of our ordered group, and name it after its parent
                        # (None_[parent])
                        if "None" in ann_val_counts.index:
                            ann_val_counts_ordered[
                                f"None_{parent_label}"
                            ] = ann_val_counts["None"]
                        # store cell type labels
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + len(ann_val_counts_ordered),
                            ),
                            f"l{level}_label",
                        ] = ann_val_counts_ordered.index
                        # store number of cells for each label
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + len(ann_val_counts_ordered),
                            ),
                            f"l{level}_size",
                        ] = ann_val_counts_ordered.values
                        # store parent label for each label
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + len(ann_val_counts_ordered),
                            ),
                            f"l{level}_parent",
                        ] = parent_label
                        # store which cmap to use for cell type, based on parent
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count
                                + n_siblings,  # len(ann_val_counts_ordered),
                            ),
                            f"l{level}_cmap",
                        ] = parent_cmap
                        # store rgba value for each label, based on cmap,
                        # cmin and cmax
                        rgba_values = list()
                        for i in range(n_siblings):
                            cvalue = (cmins[i] + cmaxs[i]) / 2
                            rgba = cm.get_cmap(parent_cmap)(cvalue[0])
                            rgba_values.append(str(rgba))
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + n_siblings,
                            ),
                            f"l{level}_rgba",
                        ] = rgba_values
                        # store cmins and cmaxs (we will use those in the
                        # next level of annotations)
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + n_siblings,
                            ),
                            f"l{level}_cmin",
                        ] = cmins.flatten()
                        color_prop_df.loc[
                            range(
                                level_ann_count,
                                level_ann_count + n_siblings,
                            ),
                            f"l{level}_cmax",
                        ] = cmaxs.flatten()
                        # if there is also a None group, store this as the
                        # next row, and give it a grey color
                        if has_none:
                            color_prop_df.loc[
                                level_ann_count + n_siblings, [f"l{level}_rgba"]
                            ] = str(grey_rgba)
                        # add a count to our loop counter
                        level_ann_count += len(ann_val_counts_ordered)
    # remove rows with NaN only:
    color_prop_df.dropna(axis=0, how="all", inplace=True)
    # calculate proportions in percentages, and perform some sanity checks:
    for l in range(1, max_level + 1):
        # check if total number of cells is the same for every level:
        if not color_prop_df[f"l1_size"].sum() == color_prop_df[f"l{l}_size"].sum():
            print(
                "WARNING: Total number of cells in level 1 and level {} are not the same in the output color_prop_df. Something went wrong!"
            )
        # calculate percentages
        color_prop_df.loc[:,f"l{l}_perc"] = color_prop_df[f"l{l}_size"] / color_prop_df[f"l{l}_size"].sum() * 100
        # check if percentages add up to 100
        if not round(color_prop_df[f"l{l}_perc"].sum()) == 100:
            print(
                f"WARNING: Rounded total percentage for level {l} does not add up to 100! Something went wrong."
            )
    return color_prop_df


def update_adata_colors(adata, color_prop_df, ann_level):
    """
    Sets adata colors of cell type annotations to the colors as stored in
    color_prop_df. color_prop_df is obtained from the
    celltype_composition_plotting.calculate_hierarchical_coloring_df() function.

    Arguments:
        adata - anndata object annotated with ann_level_1, ann_level_2_clean,
             etc. Annotations should match those in color_prop_df
        color_prop_df - output dataframe from calculate_hierarchical_coloring_df
            function.
        ann_level - int, annotation level of interest

    Returns:
        adata - anndata object with updated adata.uns colors for ann_level.

    """
    grey_rgba = cm.get_cmap("Greys")(0.5)
    if ann_level == 1:
        obs_var = f"ann_level_1"
    else:
        obs_var = f"ann_level_{ann_level}_clean"
    level_categories = adata.obs[obs_var].cat.categories
    colors = list()
    for lab in level_categories:
        if lab == "None":
            colors.append(to_hex(grey_rgba))
        else:
            idx = color_prop_df.index[color_prop_df[f"l{ann_level}_label"] == lab]
            colors.append(
                to_hex(
                    ast.literal_eval(
                        color_prop_df.loc[idx, f"l{ann_level}_rgba"].values[0]
                    )
                )
            )
    adata.uns[f"{obs_var}_colors"] = colors
    return adata


def plot_cell_type_composition_overview(
    max_level,
    color_prop_df,
    show=True,
    return_fig=False,
    fontsize=14,
    title="Lung Cell Atlas cell type composition",
    ann_level_name_prefix="original_ann_level_"
):
    labels = [f"{ann_level_name_prefix}{l}" for l in range(1, max_level + 1)]
    fig, ax = plt.subplots(figsize=(6, 6))
    bar_bottom = np.array(len(labels) * [float(0)])
    for bar_layer in range(color_prop_df.shape[0]):
        # plot first layer of bars:
        bar_heights = color_prop_df.loc[
            :, [col for col in color_prop_df.columns if col.endswith("perc")]
        ].iloc[bar_layer, :]
        bar_heights.fillna(0, inplace=True)
        bar_colors = color_prop_df.loc[
            :, [col for col in color_prop_df.columns if col.endswith("rgba")]
        ].iloc[bar_layer, :]
        bar_colors.fillna("(0.0, 0.0, 0.0, 0.0)", inplace=True)
        bar_colors = [
            ast.literal_eval(rgba_str) for rgba_str in list(bar_colors.values)
        ]
        ax.bar(
            labels,
            bar_heights,
            width=0.8,
            bottom=bar_bottom,
            color=bar_colors,
            edgecolor="black",
            linewidth=0.4,
        )
        bar_bottom += bar_heights.values
    # ax.bar(labels, women_means, width, yerr=women_std, bottom=men_means, label="Women")
    ax.set_xticklabels(range(1,max_level + 1))
    ax.tick_params(bottom=True, left=True, labelsize=fontsize)
    ax.set_xlabel("annotation level", fontsize=fontsize)
    ax.set_ylabel("% of cells", fontsize=fontsize)
    ax.set_title(title, fontsize=fontsize)
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    # ax.legend(loc="lower right")
    plt.grid(False)
    plt.tight_layout()
    if show:
        plt.show()
    if return_fig:
        return fig
    else:
        plt.close()



def plot_cell_type_composition_single_level_with_legend(
    color_prop_df, 
    level, 
    figsize=(6, 6), 
    width=0.6,
    add_perc_to_legend=False, 
    show=True, 
    return_fig=False,
    ann_level_name_prefix="original_ann_level_"
):
    width = 0.6  # the width of the bars: can also be len(x) sequence
    fig, ax = plt.subplots(figsize=figsize)
    bar_bottom = 0
    l = level
    l_zero_indexed = l - 1
    for bar_layer in range(color_prop_df.shape[0]):
        # plot first layer of bars:
        bar_height = color_prop_df.loc[
            :, [col for col in color_prop_df.columns if col.endswith("perc")]
        ].iloc[bar_layer, l_zero_indexed]
        if not pd.isnull(bar_height):
            bar_color = color_prop_df.loc[
                :, [col for col in color_prop_df.columns if col.endswith("rgba")]
            ].iloc[bar_layer, l_zero_indexed]
            #         bar_colors.fillna("(0.0, 0.0, 0.0, 0.0)", inplace=True)
            bar_color = ast.literal_eval(bar_color)
            ax.bar(
                f"{ann_level_name_prefix}{l}",
                bar_height,
                width,
                bottom=bar_bottom,
                color=bar_color,
                label=color_prop_df[f"l{l}_label"][bar_layer],
                edgecolor="black",
                linewidth=0.4,
            )
            bar_bottom += bar_height
    # ax.bar(labels, women_means, width, yerr=women_std, bottom=men_means, label="Women")
    ax.tick_params(axis="x", rotation=90)
    ax.set_ylabel("percentage")
    ax.set_title("Lung Cell Atlas cell type composition")
    # prepare legend:
    handles, labels = ax.get_legend_handles_labels()
    # keep only one "None_" label, since all "None" labels are grey and
    # should be named "unannotated"
    # store the label indices starting with None
    none_label_idc = np.array(
        [idx for idx, lab in enumerate(labels) if lab.startswith("None")]
    )
    # if there are any, adapt handles:
    if len(none_label_idc) > 0:
        # rename the first None_ label to "unannotated"
        labels[none_label_idc[-1]] = "unannotated"
        # remove the other None labels and their matching handles from
        # our labels and handles:
        n_labels = len(labels)
        labels = [labels[i] for i in range(n_labels) if i not in none_label_idc[:-1]]
        handles = [handles[i] for i in range(n_labels) if i not in none_label_idc[:-1]]
    # add percentages to labels:
    if add_perc_to_legend:
        for label_idx, label in enumerate(labels):
            if label == "unannotated":
                label_perc = np.round(
                    color_prop_df[f"l{l}_perc"][
                        color_prop_df[f"l{l}_label"]
                        .str.startswith("None")
                        .replace(np.nan, False)
                    ].sum()
                )
            else:
                label_perc = np.round(
                    color_prop_df.loc[color_prop_df[f"l{l}_label"] == label, f"l{l}_perc"].values[
                        0
                    ],
                    1,
                )
            labels[label_idx] = f"{label} ({label_perc})"
    for label_n, label in enumerate(labels):
        if label == "Megakaryocytic and erythroid":
            labels[label_n] = "Megakaryocytic\nand erythroid"
    # add legend
    leg = ax.legend(
        handles[::-1],
        labels[::-1],
        loc="upper left",
        bbox_to_anchor=(1.05, 1),
        frameon=False
    )
    leg.set_title(f"level {l}", prop={"size": "large"})
    leg._legend_box.align = "left"
    plt.grid(None)
    plt.tight_layout()
    if show:
        plt.show()
    if return_fig:
        return fig
    else:
        plt.close()



def plot_subadata_cell_type_composition_with_LCA_coloring(
    subadata,
    color_prop_df,
    level,
    figsize=(6, 6),
    show=True,
    return_fig=False,
    title="title",
    fontsize=10,
    ann_level_name_prefix="original_ann_level_"
):
    """Plots compositional bar plot for a given adata that is a sub-part
    of a larger adata object, using coloring that has been calculated
    on the whole object.
    Arguments:
    subadata - anndata object of cells for which we want to plot composition
    color_prop_df - dataframe that was generated with
        celltype_composition_plotting.calculate_hierarchical_coloring_df()
        function. This contains coloring and ordering info for celltypes.
    level - annotation level to use
    figsize - figure size (tuple)
    show - show figure
    return_fig - return matplotlib figure object
    title - string of title for figure
    fontsize - fontsize of labels
    ann_level_name_prefix - string of annotation level naming prefix

    Returns:
    nothing if return_fig set to False, but prints figure if show set to True.
    returns figure if return_fig set to True
    """
    # set color for unannotated cells
    grey_rgba = str(cm.get_cmap("Greys")(0.5))
    # calculate cell type proportions in subadata
    prop_df = subadata.obs[f"{ann_level_name_prefix}{level}_clean"].value_counts()
    prop_df = prop_df / prop_df.sum() * 100
    # order cell type labels in subadata based on color_prop_df,
    # and extract matching colors
    ct_labels, rgbas = zip(
        *[
            (lab, col)
            for lab, col in zip(
                color_prop_df[f"l{level}_label"], color_prop_df[f"l{level}_rgba"]
            )
            if lab in prop_df
        ]
    )
    ct_labels, rgbas = list(ct_labels), list(rgbas)
    # note that None is not in color_prop_df, and so needs to be added now
    if "None" in prop_df.index and "None" not in ct_labels:
        ct_labels.append("None")
        rgbas.append(grey_rgba)
    # set figure parameters
    width = 0.6  # the width of the bars: can also be len(x) sequence
    fig, ax = plt.subplots(figsize=figsize)
    bar_bottom = 0
    l = level
    l_zero_indexed = l - 1
    # loop through cell types
    for bar_layer in range(len(ct_labels)):
        label = ct_labels[bar_layer]
        # plot first layer of bars:
        bar_height = prop_df.loc[label]
        if not pd.isnull(bar_height):
            bar_color = ast.literal_eval(rgbas[bar_layer])
            ax.bar(
                f"{ann_level_name_prefix}{l}",
                bar_height,
                width,
                bottom=bar_bottom,
                color=bar_color,
                label=label,
                edgecolor="black",
                linewidth=0.4,
            )
            bar_bottom += bar_height
    # ax.bar(labels, women_means, width, yerr=women_std, bottom=men_means, label="Women")
    ax.tick_params(labelsize=fontsize, bottom=False, labelbottom=False)
    ax.set_xlabel(None)
    ax.set_ylabel("percentage",fontsize=fontsize)
    ax.set_title(title, fontsize=fontsize)
    # prepare legend:
    handles, labels = ax.get_legend_handles_labels()
    # keep only one "None_" label, since all "None" labels are grey and
    # should be named "unannotated"
    # store the label indices starting with None
    none_label_idc = np.array(
        [idx for idx, lab in enumerate(labels) if lab.startswith("None")]
    )
    # if there are any, adapt handles:
    if len(none_label_idc) > 0:
        # rename the first None_ label to "unannotated"
        labels[none_label_idc[-1]] = "unannotated"
        # remove the other None labels and their matching handles from
        # our labels and handles:
        n_labels = len(labels)
        labels = [labels[i] for i in range(n_labels) if i not in none_label_idc[:-1]]
        handles = [handles[i] for i in range(n_labels) if i not in none_label_idc[:-1]]
    # add percentages to labels:
    for label_idx, label in enumerate(labels):
        if label == "unannotated":
            label_perc = np.round(prop_df[prop_df.index.str.startswith("None")].sum())
        else:
            label_perc = np.round(prop_df[label], 1)
        labels[label_idx] = f"{label} ({label_perc})"
    # add legend
    leg = ax.legend(
        handles[::-1],
        labels[::-1],
        loc="upper left",
        bbox_to_anchor=(1.05, 1),
    )
    leg.set_title(f"ann_level_{l}", prop={"size": "xx-large"})
    plt.grid(None)
    plt.tight_layout()
    if show:
        plt.show()
    if return_fig:
        return fig
    else:
        plt.close()


def plot_celltype_composition_per_sample(
    adata,
    ann_level_number,
    color_prop_df,
    fontsize=14,
    figsize=(17.5, 5),
    title="",
    show=True,
    return_fig=False,
    ann_level_name_prefix="original_ann_level_"
):
    """function that plots a bor plot of cell type composition per sample.

    Arguments:
        adata - anndata object, with cell type annotations
        ann_level_number - integer of annotation level of interest
        color_prop_df - pandas dataframe that contains coloring information,
            output of calculate_hierarchical_coloring_df() function
        fontsize - fontsize integer
        figsize - figuresize tuple
        title - string of figure title
        show - Boolean, whether or not to show figure
        return_fig - Boolean, wheter or not to return figure
        ann_level_name_prefix - string of annotation level naming prefix

    Returns:
        nothing if return_fig set to False
        matplotlib figure if return_fig set to True
    """
    if ann_level_number == "1":
        ann_level = f"{ann_level_name_prefix}{ann_level_number}"
    else:
        ann_level = f"{ann_level_name_prefix}{ann_level_number}_clean"
    grouping_covariate = "sample"
    data_per_sample = (
        adata.obs.groupby("sample")
        .agg(
            {
                "anatomical_region_ccf_score": "first",
                "anatomical_region_level_1": "first",
                "study": "first",
            }
        )
        .sort_values(by=["anatomical_region_ccf_score", "study"])
    )
    # store sample order
    grouping_covariate_order = data_per_sample.index
    # store celltype order
    ct_order = list()
    for label in color_prop_df[f"l{ann_level_number}_label"]:
        if label not in ct_order:
            ct_order.append(label)
    # Data
    df = (
        adata.obs.groupby([ann_level, grouping_covariate])
        .agg({grouping_covariate: "count"})
        .unstack()
        .T
    )
    df.index = df.index.droplevel(0)
    # order
    df = df.loc[grouping_covariate_order, :]
    # order according to previously calculated order
    # convert to percentages per row:
    df = df.divide(df.sum(axis=1), axis="rows")
    # cell type names (y-axis):
    ct_names = df.columns.tolist()
    if "None" in ct_names:
        has_none = True
    else:
        has_none = False
    # order ct names based on hierarchical reference
    ct_names = [label for label in ct_order if label in ct_names]
    if has_none:
        ct_names.append("None")
    # store grey color:
    grey_rgba = str(cm.get_cmap("Greys")(0.5))
    # set names plus locations for x ticks
    x_names = df.index.tolist()
    x_bar_locations = [i for i in range(len(x_names))]
    # for each cell type, store the percentage of the cell type for each dataset
    # in a dict with cell types as keys, and list of percentages as values
    bars = dict()
    for ct in ct_names:
        bars[ct] = [i * 100 for i in df[ct]]
    # plot figure
    fig, ax = plt.subplots(figsize=figsize)
    bottom = np.zeros(shape=(df.shape[0]))
    # now loop through celltypes
    for i, ct in enumerate(ct_names):
        # set color to grey if ct is "None"
        if ct == "None":
            color = ast.literal_eval(grey_rgba)
            label = "unannotated"
        else:
            color = ast.literal_eval(
                color_prop_df.loc[
                    color_prop_df[f"l{ann_level_number}_label"] == ct,
                    f"l{ann_level_number}_rgba",
                ].values[0]
            )
            label = ct
        ax.bar(
            x=x_bar_locations,
            height=bars[ct],
            width=1,
            bottom=bottom,
            color=color,  # cols[i + 1],
            edgecolor="black",
            label=label,
            linewidth=0.4            
        )
        bottom += bars[ct]
    ax.spines["right"].set_visible(False)
    ax.spines["top"].set_visible(False)
    ax.tick_params("x", labelsize=fontsize, bottom=True, left=True)
    ax.tick_params("y", labelsize=fontsize)
    # label the first nose, airway and parenchyma sample:
    first_nose = np.where(data_per_sample["anatomical_region_level_1"] == "nose")[0][0]
    first_airway = np.where(data_per_sample["anatomical_region_level_1"] == "airway")[
        0
    ][0]
    first_parenchyma = np.where(
        data_per_sample["anatomical_region_level_1"] == "parenchyma"
    )[0][0]
    ax.set_xticks(ticks=[first_nose, first_airway, first_parenchyma])
    ax.set_xticklabels(labels=["nose", "airway", "parenchyma"], fontsize=fontsize)
    ax.set_xlabel("sample", fontsize=fontsize)
    ax.set_ylabel("% of cells", fontsize=fontsize)
    # Add a legend
    handles, labels = ax.get_legend_handles_labels()
    for label_n, label in enumerate(labels):
        if label == "Megakaryocytic and erythroid":
            labels[label_n] = "Megakaryocytic\nand erythroid"
    leg = ax.legend(
        handles[::-1],
        labels[::-1],
        loc="upper left",
        bbox_to_anchor=(1, 1),
        ncol=1,
        fontsize=fontsize,
        frameon=False,
    )
    plt.title(
        title,
        fontsize=fontsize,
    )
    # Show graphic
    plt.grid(False)
    if show:
        plt.show()
    plt.close()
    if return_fig:
        return fig
